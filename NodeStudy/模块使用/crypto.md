> 参考 http://blog.fens.me/nodejs-crypto/
const crypto = require('crypto');
## hash加密   
由于md5已经有了大量的字典库，对于安全级别一般的网站用sha1吧；如果安全级别要求很高，CPU配置也很牛，可以考虑用sha512


## 加密和解密算法
对于登陆密码来说，是不需要考虑解密的，通常都会用不可逆的算法，像md5,sha-1等。但是，对于有安全性要求的数据来说，我们是需要加密存储，然后解密使用的，这时需要用到可逆的加密算法。对于这种基于KEY算法，可以分为对称加密和不对称加密。

对称加密算法的原理很容易理解，通信一方用KEK加密明文，另一方收到之后用同样的KEY来解密就可以得到明文。
不对称加密算法，使用两把完全不同但又是完全匹配的一对Key:公钥和私钥。在使用不对称加密算法加密文件时，只有使用匹配的一对公钥和私钥，才能完成对明文的加密和解密过程。

rc4和aes-256-cbc是表现不错的算法，加密和解密时间都比较短，加密时间:解密时间=1:3；其他的算法，有的加密时间:解密时间=1:1。所以，怎么选算法，另外的一个标准就要看业务需求了。如果业务上，解密操作的次数远大于加密操作的次数，而且是在服务器计算，那么我们最好找到，加密时间:解密时间=N:1，N>1的算法；如果加密在服务器端，解密在客户端完成，那么aes-256-cbc算法的计算时间比例就非常适合了。


## 签名和验证算法
我们除了对数据进行加密和解密，还需要判断数据在传输过程中，是否真实际和完整，是否被篡改了。那么就需要用到签名和验证的算法，利用不对称加密算法，通过私钥进行数字签名，公钥验证数据的真实性。

## salt算法
我们知道，如果直接对密码进行散列，那么黑客可以对通过获得这个密码散列值，然后通过查散列值字典（例如MD5密码破解网站），得到某用户的密码。

盐（Salt），在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。加盐后的散列值，可以极大的降低由于用户数据被盗而带来的密码泄漏风险，即使通过彩虹表寻找到了散列后的数值所对应的原始内容，但是由于经过了加盐，插入的字符串扰乱了真正的密码，使得获得真实密码的概率大大降低。

加盐的实现过程通常是在需要散列的字段的特定位置增加特定的字符，打乱原始的字串，使其生成的散列结果产生变化。比如，用户使用了一个密码：
123465
经过MD5散列后，可以得出结果：
3d9188577cc9bfe9291ac66b5cc872b7
但是由于用户密码位数不足，短密码的散列结果很容易被彩虹表破解，因此，在用户的密码末尾添加特定字串：
123465abcdefghijklmnopqrstuvwxyz
因此，加盐后的密码位数更长了，散列的结果也发生了变化：
27e20c64ccb8cce9ad68b8ccff6252cf