## 有损压缩
- 有损压缩就是在存储图像的时候并不完全真实的记录图像上每个像素点的数据信息，他会根据人眼观察现实世界的特性（人眼对光线的敏感度比对颜色的敏感度要高）对图像数据进行处理，去掉那些图像上会被人眼忽略的细节，然后使用附近的颜色通过渐变或其他形式进行填充。这样既能大大降低图像信息的数据量，又不会影响图像的还原效果。
- JPG是最常见的采用有损压缩对图像信息进行处理的图片格式。JPG在存储图像时会把图像分成==8 * 8==像素的栅格，然后对每个栅格的数据进行压缩处理，当我们放大一张图像的时候，就会发现这些==8 * 8==像素栅格中很多细节信息被删除，而通过一些特殊算法用附近的颜色进行填充。这也是为什么我们用JPG存储图形有时会产生块状模糊的原因。

## 无损压缩
- 无损压缩则是真实的记录图像上每个像素点的数据信息，但为了压缩图像文件的大小会采用一些特殊的算法。无损压缩的压缩原理是先判断图像上哪些区域的颜色是相同的，哪些是不同的然后把这些相同的数据信息进行压缩记录，（例如一片蓝色的天空只需要记录起点和终点的位置就可以了），而把不同的数据另外保存（例如天空上的白云和渐变等数据）。
```
少用图片元素，尽量用css3代替。 比如圆角，提示框，不会二次渲染的元素的阴影。
尽量少用png32格式，太大了。在某些情况下，如果损失一定的视觉可以获得性能较大的提升，可以和设计师协商去掉一些效果。
JPG适合摄影图像或写实图像，同时也适合颜色较少图像；PNG8 适合所含颜色很少(少于256)、具有大块颜色相近的区域或亮度差异十分明显的较简单的图片；PNG32适合图片较为复杂且有透明效果且透明效果无法用css来实现的情况。
如果页面中有较多的小icon，首先考虑使用webfont，如果webfont不能满足需求，必须使用css sprite将图片合并，来压缩总体图片的大小，同时减少页面请求提高访问速度。
```
## JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，用来表达更生动的图像效果，比如颜色渐变。
1. 对色彩要求不高同时需要文件体积较小的场景，比如企业Logo、线框类的图等，应该尽可能的使用PNG-8而不是GIF，PNG8除了不支持动画外，PNG8有GIF所有的特点，但是比GIF更加具有优势的是它支持alpha透明和更优的压缩（GIF仅支持索引透明）体积，PNG-8还支持透明度的调节，而GIF并不支持。对比之下gif的优点只有更加好的兼容支持动画
1. 一般层次丰富颜色较多的图像采用JPG存储，而颜色简单对比强烈的则需要采用PNG。
1. 不要存100%品质的JPG格式图片。因为100%并不一定是最高的品质，而是一个优化算法的极限值，所以会增加不必要的文件大小。建议存储95%品质的图片就可以最大限度的降低失真
1. SVG优点
- 图像文件可读，易于修改和编辑（理论上如此，但实际上却是因为各种不同的SVG档编辑器而可能存储成不易解读的SVG文件）；
- 与现有技术可以互动融合。例如，SVG技术本身的动态部分（包括时序控制和动画）就是基于SMIL标准。另外，SVG文件还可嵌入JavaScript（严格地说，应该是ECMAScript）脚本来控制SVG对象；
- SVG图形格式可以方便的创建文字索引，从而实现基于内容的图像搜索；
- SVG图形格式支持多种滤镜和特殊效果，在不改变图像内容的前提下可以实现位图格式中类似文字阴影的效果； SVG图形格式可以用来动态生成图形。例如，可用SVG动态生成具有交互功能的地图，嵌入网页中，并显示给终端用户；
- 矢量图形，文件比较小，同时也能提供高清晰的画面，适合于直接打印或输出。
1. SVG缺点
- SVG的本地运行环境下的厂家支持程度；
- 由于原始的SVG档是遵从XML语法，导致数据采用未压缩的方式存放，因此相较于其他的矢量图形格式，同样的文件内容会比其他的文件格式稍大
- 旧版的SVG Viewer无法正确显示出使用新版SVG格式的矢量图形。
## 最新的图片格式有webp，不过兼容性不是很好，在未来应该会大幅使用
- webp是一种同时提供了有损压缩与无损压缩的图片文件格式，WebP支持无损压缩和透明色的功能，派生自视频编码格式VP8，是由Google在购买On2 Technologies后发展出来，以BSD授权条款发布。 目标是减少文件大小，但达到和JPEG格式相同的图片质量，希望能够减少图片档在网络上的发送时间。
根据Google较早的测试，WebP的无损压缩比网络上找到的PNG档少了45％的文件大小，即使这些PNG档在使用pngcrush和PNGOUT处理过，WebP还是可以减少28％的文件大小。
## 使用CssSprites合并为一张大图：
1. 页面具有多种风格，需要换肤功能，可使用CssSprites
1. 网站已经趋于完美，不会再三天两头的改动（例如button大小、颜色等）
1. 使用时无需重复图形内容
1. 没有 Base64 编码成本，降低图片更新的维护难度。（但注意 Sprites 同时修改 css 和图片某些时候可能造成负担）
1. 不会增加 CSS 文件体积

## 使用base64直接把图片编码成字符串写入CSS文件：
1. 无额外请求
1. 对于极小或者极简单图片，就自己项目开发而言，只有小于 10K 的图标，才会进行转码。
1. 可像单独图片一样使用，比如背景图片重复使用等
1. 没有跨域问题，无需考虑缓存、文件头或者cookies问题 
1. 缺点是需要消耗CPU进行编解码和页面不简洁

## 什么时候用`img`？
1. 这个图是内容的一部分，而不是背景。
1. 如果图片加载不出来，需要alt属性告诉用户这是什么。
1. 当你需要打印这个页面，img可以打印出来，而背景图会被忽略。
1. 当你需要无障碍阅读这个页面（如盲人阅读器）的时候，只有img图的alt属性是被传递的信息。
1. 该图需要被SEO（搜索引擎优化），需要被搜的到，alt很重要。
1. 这个图需要被优先第一时间加载并呈现给用户。
## 什么时候用`background-image`？
1. 和内容无关，可以被忽略，可能只是美化作用。
1. 这可能是个背景，或提示信息，如图标／背景动画等。
1. 需要处理css3动画的效果。

##区域有图片不一定要用img标签，可以用background

前端通过接口接受图片流文件
```
arrayBuffer式
var xhr = new XMLHttpRequest();
	xhr.open("GET", "http://127.0.0.1:3000/users/png", true);
	xhr.responseType = "arrayBuffer";
	xhr.onload = function () {
		// 	console.log(xhr.response)
    var bytes = new Uint8Array(xhr.response);
    var data = "";
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
       data += String.fromCharCode(bytes[i]);
     }
     var src = "data:image/png;base64," + window.btoa(data);
     //console.log(src)
   }
   xhr.send();
   
blob式
var xhr = new XMLHttpRequest();
	xhr.open("GET", "http://127.0.0.1:3000/users/png", true);
	xhr.responseType = "blob";
	xhr.onload = function () {
		// 	console.log(xhr.response)
    var img = document.createElement('img')
    // 元素的onload 事件触发后将销毁URL对象, 释放内存。
    img.onload = function (e) {
       window.URL.revokeObjectURL(img.src)
     }
   // 浏览器允许使用URL.createObjectURL()方法，针对 Blob 对象生成一个临时 URL。
   // 这个 URL 以blob://开头,表明对应一个 Blob 对象。
     img.src = window.URL.createObjectURL(xhr.response)
     //console.log(img.src),打印的是一个blob，必须显示图片才能看到全部图片内容
     document.body.append(img)
	}
	xhr.send();
  
有些像验证码的图片是直接赋值在图片的src上，形如img.src = 'http://127.0.0.1:3000/users/png?scene=qrb=' + _mac + "&locktype=" + _locktype+"path"+ "pages/qrcode/qrcode";,无须通过xhr请求
```
